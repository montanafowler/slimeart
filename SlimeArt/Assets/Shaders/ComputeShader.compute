
// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;

RWStructuredBuffer<float> particles_x; //x positons of every particle normalized
RWStructuredBuffer<float> particles_y; // y positions of every particle normalized
RWStructuredBuffer<float> particles_theta; // direction of movement for every particle
RWStructuredBuffer<float> particle_weights; // how strong a deposit
RWTexture2D<float> tex_deposit;
RWTexture2D<float4> tex_trace;

float half_sense_spread; // default = 15-30 degrees
float sense_distance; // in world-space units; default = about 1/100 of the world 'cube' size
float turn_angle; // default = 15 degrees
float move_distance; // in world-space units; default = about 1/5--1/3 of sense_distance
float agent_deposit; // 0 for data-driven fitting, >0 for self-reinforcing behavior
int world_width; //
int world_height; // grid dimensions - note that the particle positions are also stored in the grid coordinates, but continuous
int world_depth; //
float move_sense_coef;
float normalization_factor;

float pixelWidth;
float pixelHeight;

#define PI 3.141592
#define HALFPI 0.5 * PI
#define TWOPI 2.0 * PI

struct RNG {
    #define BAD_W 0x464fffffU
    #define BAD_Z 0x9068ffffU
    uint m_w;
	uint m_z;

    void set_seed(uint seed1, uint seed2)
	{
		m_w = seed1;
		m_z = seed2;
		if (m_w == 0U || m_w == BAD_W) ++m_w;
		if (m_w == 0U || m_z == BAD_Z) ++m_z;
	}

    void get_seed(out uint seed1, out uint seed2)
    {
        seed1 = m_w;
        seed2 = m_z;
    }

    uint random_uint()
	{
		m_z = 36969U * (m_z & 65535U) + (m_z >> 16U);
		m_w = 18000U * (m_w & 65535U) + (m_w >> 16U);
		return uint((m_z << 16U) + m_w);
	}

    float random_float()
	{
		return float(random_uint()) / float(0xFFFFFFFFU);
	}
};

uint wang_hash(uint seed)
{
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    return seed;
}

float2 rotate(float2 v, float2 a, float angle) {
    float3 result = float3(0.0,0.0,0.0);//cos(angle) * v + sin(angle) * (cross(a, v)) + dot(a, v) * (1.0 - cos(angle)) * a;
  //  float2 result = float2(cos(angle) * )
    return result;
}

float mod(float x, float y) {
    return x - y * floor(x / y);
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID) {
//void main(uint thread_index : SV_GroupIndex, uint3 group_id : SV_GroupID)
    //uint group_idx = group_id.x + group_id.y * 10 + group_id.z * 100;
    //uint idx = thread_index + 1000 * group_idx;

    uint idx = id.x + id.y * pixelWidth; // not sure if this is right 7/3/20

    // Fetch current particle state
    float x = particles_x[idx];// *pixelWidth;
    float y = particles_y[idx];// *pixelHeight;
    float theta = particles_theta[idx];
    float particle_weight = particle_weights[idx];
    bool is_data = (theta < -1.0); // FLAG IF TRUE PUT THE GALIXY IN THE DEPOSIT // RANDOMLY WRITE DOTS SO I ESTABLISH THE COMMUNICATION BETWEEN THE TWO SHADERS

    // Make a step
    float xi = 0.5;//clamp(rng.random_float(), 0.001, 0.999); // random for each particle and timestep
    float distance_scaling_factor = -0.3033 * log((pow(xi + 0.005, -0.4) - 0.9974) / 7.326); // using Maxwell-Boltzmann distribution
    float2 dp = float2(cos(theta), sin(theta)) * move_distance * (0.1 + 0.9 * distance_scaling_factor);
    
    
    /*if ((x + dp.x) > pixelWidth || (x + dp.x) < 0.0) {
        theta = atan2(sin(theta), -cos(theta));
        dp = float2(cos(theta), sin(theta)) * move_distance * (0.1 + 0.9 * distance_scaling_factor);
    } 

    if ((y + dp.y) > pixelHeight || (y + dp.y) < 0.0) {
        theta = atan2(-sin(theta), cos(theta));
        dp = float2(cos(theta), sin(theta)) * move_distance * (0.1 + 0.9 * distance_scaling_factor);
    } */

    x += dp.x;
    y += dp.y;
    
    
    
    // Keep the particle inside environment
    x = fmod(x, world_width); // problem 7/28
    y = fmod(y, world_height);
    

    // Update particle state
    particles_x[idx] = x;
    particles_y[idx] = y;
    particles_theta[idx] = theta;

    Result[id.xy] = float4(0.0, 0.0, 0.0, 1.0);//float4(id.x / 512.0, id.y / 512.0, 0.3, 1.0);
    Result[uint2(x, y)] = float4(1.0, 1.0, 1.0, 1.0);//float4(x / 512.0, y / 512.0, 0.8, 1.0);

    /*// If data, then just write out deposit and exit
    if (is_data) {
        tex_deposit[uint2(x, y)] += 10.0 * particle_weight; // NOT ATOMIC! (not sure what particle weight is... maybe parameter?)
        return;
    }

    RNG rng;
    rng.set_seed(
        wang_hash(359*idx),
        wang_hash(uint(x*y))
    );

    // Get vector which points in the current particle's direction
    float2 center_axis = float2(cos(theta), sin(theta));

    // Get base vector which points away from the current particle's direction and will be used to sample environment in other directions
    float sense_theta = theta - half_sense_spread; // sense spread is the difference between the cone's center and the side of it
    float2 cone_edge_direction = float2(cos(sense_theta), sin(sense_theta)); //RIGHT? 7/3/20 float3(sin(sense_theta) * cos(ph), cos(sense_theta), sin(sense_theta) * sin(ph));

    // Probabilistic sensing,  how far out you sense is random
    float sense_distance_prob = sense_distance;
    float xi = clamp(rng.random_float(), 0.001, 0.999); // random for each particle and timestep
    float distance_scaling_factor = -0.3033 * log( (pow(xi+0.005, -0.4) - 0.9974) / 7.326 ); // using Maxwell-Boltzmann distribution
    sense_distance_prob *= distance_scaling_factor;

    // Sample environment along the movement axis
    int2 p = int2(x, y); // current location of particle
    float current_deposit = tex_deposit[p]; // deposit at current location
    float2 center_sense_pos = center_axis * sense_distance_prob; // the random point along the direction the particle is traveling
    float deposit_ahead = tex_deposit[p + int2(center_sense_pos)]; // sample from that random point to get the deposit

    // Stochastic MC direction sampling
    float random_angle = rng.random_float() * half_sense_spread * 2.0 + sense_theta; //TWOPI - PI; // random angle between -pi and +pi, random azimuth
    // I think off_center_base_dir/cone_edge_direction is the direction of theta - sense spread
    // so then I think this rotation is picking a vector at the random angle between these two vectors in another plane
    float2 sense_offset = float2(cos(random_angle), sin(random_angle)) * sense_distance_prob; //rotate(off_center_base_dir, center_axis, random_angle) * sense_distance_prob; // is this gonna work? 7/3/20
    float sense_deposit = tex_deposit[p + int2(sense_offset)];

    float sharpness = move_sense_coef;
    float p_straight = pow(max(deposit_ahead, 0.0), sharpness);
    float p_turn = pow(max(sense_deposit, 0.0), sharpness);
    float xiDir = rng.random_float();

    // if there is nonzero deposit in either the random sample or the sample ahead
    if (p_straight + p_turn > 1.0e-5) {

        // if there is more deposit towards random angle
        if (p_turn > p_straight) {
            float theta_turn = theta - turn_angle;
            float2 cone_edge_direction_turn = float2(cos(theta_turn), sin(theta_turn));
            float2 new_direction = float2(cos(random_angle), sin(random_angle)); //rotate( cone_edge_direction_turn, center_axis, random_angle);
            theta = atan2(new_direction.y, new_direction.x); //atan2(new_direction.z, new_direction.x); // not sure which it should be
            //th = acos(new_direction.y / length(new_direction));
        }
    }

    // Make a step
    float2 dp = float2(cos(theta), sin(theta)) * move_distance * (0.1 + 0.9 * distance_scaling_factor);
    x += dp.x;
    y += dp.y;


    // Keep the particle inside environment
    x = mod(x, world_width);
    y = mod(y, world_height);

    // Update particle state
    particles_x[idx] = x;
    particles_y[idx] = y;
    particles_theta[idx] = theta;
    //particles_weights[idx] = particle_weight;

    // Update deposit and trace grids
    tex_deposit[uint2(x, y)] += agent_deposit; // NOT ATOMIC! // the trace is not blurred, trace is not food, but agents also leave deposit
    tex_trace[uint2(x, y)] += float4(distance_scaling_factor, abs(center_axis.x), abs(center_axis.y), 1.0); // NOT ATOMIC!
    //float4(distance_scaling_factor/*actualtrace, abs(center_axis.x), abs(center_axis.y), abs(center_axis.z)/*direction of agents); // NOT ATOMIC!


  if (id.x % 20 > 10 && id.y % 20 > 10) {
    //  if (id.x <= 512/2.0 && id.x >= (512/2.0 - 5.0) && id.y <= 512/2.0 && id.y >= (512/2.0 - 5.0)) {
    //if (id.x < pixelWidth/2 && id.x > pixelWidth/2 - 10 && id.y < pixelWidth/2 && id.y > pixelWidth/2 - 10) {
      //Result[id.xy] = float4(particles_x[0], particles_x[1],   particles_x[2], 1.0);
    //Result[id.xy] = float4(10.0, 0.0, 0.0, 1.0);
    } else {
      //Result[id.xy] = float4(0.0, 0.0, 0.0, 1.0);
    }
    float test = 0.0;
    if (id.x < 1.0) test = 1.0;
  //  Result[id.xy] = float4(idx/(512.0*512.0), (idx-1)/(512.0*512.0), 0.0, 1.0);
  //  Result[id.xy] = float4(id.x/512.0, id.y/512.0, 0.0, 1.0);
    Result[id.xy] = float4(id.x/512.0, id.y/512.0, 0.3, 1.0);
    Result[uint2(x,y)] = float4(0.0, 0.0, 0.0, 1.0);
    */
    //if(x > 0.0) 
      //  Result[uint2(500, 500)] = float4(0.0, 0.0, 0.0, 1.0);
   
    //if(x > 0.0 && y > 0.0) {
      //Result[uint2(x,y)] = float4(1.0, 1.0, 1.0, 1.0);
    //} else {
      //Result[uint2(x,y)] = float4(1.0, 0.0, 0.0, 1.0);
    //}

  /*  if(id.x < 512/6) {
      Result[id.xy] = float4(0.0,0.0,0.0,1.0);
    } else if(id.x < 512/6*2) {
      Result[id.xy] = float4(1.0,0.4,0.0,1.0);
    } else if(id.x < 512/6*3) {
      Result[id.xy] = float4(1.0,1.0,0.0,1.0);
    } else if(id.x < 512/6*4) {
      Result[id.xy] = float4(0.0,1.0,0.0,1.0);
    } else if(id.x < 512/6*5) {
      Result[id.xy] = float4(0.0,0.0,1.0,1.0);
    } else if(id.x < 512/6*6) {
      Result[id.xy] = float4(1.0,0.0,1.0,1.0);
    }

  if(x < 512/6 && y < 512/6) {
    Result[id.xy] = float4(1.0,0.0,0.0,1.0);
  } else if(x < 512/6*2 && y < 512/6*2) {
    Result[id.xy] = float4(1.0,0.4,0.0,1.0);
  } else if(x < 512/6*3 && y < 512/6*3) {
    Result[id.xy] = float4(1.0,1.0,0.0,1.0);
  } else if(x < 512/6*4 && y < 512/6*4) {
    Result[id.xy] = float4(0.0,1.0,0.0,1.0);
  } else if(x < 512/6*5 && y < 512/6*5) {
    Result[id.xy] = float4(0.0,0.0,1.0,1.0);
  } else if(x < 512/6*6 && y < 512/6*6) {
    Result[id.xy] = float4(1.0,0.0,1.0,1.0);
  }

    if(idx < 512*512/6) {
      Result[id.xy] = float4(1.0,0.0,0.0,1.0);
    } else if(idx < 512*512/6*2) {
      Result[id.xy] = float4(1.0,0.4,0.0,1.0);
    } else if(idx < 512*512/6*3) {
      Result[id.xy] = float4(1.0,1.0,0.0,1.0);
    } else if(idx < 512*512/6*4) {
      Result[id.xy] = float4(0.0,1.0,0.0,1.0);
    } else if(idx < 512*512/6*5) {
      Result[id.xy] = float4(0.0,0.0,1.0,1.0);
    } else if(idx < 512*512) {
      Result[id.xy] = float4(1.0,0.0,1.0,1.0);
    }
    if(id.x < 512 && id.x > (512-512/6) && id.y < 512 && id.y > (512-512/6)) {
      Result[id.xy] = float4(1.0,1.0,1.0,1.0);
    }

*/
}
